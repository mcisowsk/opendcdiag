/*
 * Copyright 2024 Intel Corporation.
 * SPDX-License-Identifier: Apache-2.0
 */

#include "sandstone_p.h"
#include "sandstone_opts.hpp"

#include <boost/program_options.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/format.hpp>

#include <cinttypes>
#include <iostream>
#include <string>
#include <string_view>
#include <type_traits>
#include <vector>

using namespace std::chrono;

using namespace std::chrono_literals;

namespace po = boost::program_options;

namespace {
void usage(char **argv)
{
    static const char usageText[] = R"(%s [options]

Common command-line options are:
 -F, --fatal-errors
     Stop execution after first failure; do not continue to run tests.
 -T <time>, --total-time=<time>
     Specify the minimum run time for the program.  A special value for <time>
     of "forever" causes the program to loop indefinitely.  The defaults for <time>
     is milliseconds, with s, m, and h available for seconds, minutes or hours.
     Example: sandstone -T 60s     # run for at least 60 seconds.
     Example: sandstone -T 5000    # run for at least 5,000 milliseconds
 --strict-runtime
     Use in conjunction with -T to force the program to stop execution after the
     specific time has elapsed.
 -t <test-time>
     Specify the execution time per test for the program in ms.
     Value for this field can also be specified with a label s, m, h for seconds,
     minutes or hours.  Example: 200ms, 2s or 2m
 --max-test-count <NUMBER>
     Specify the maximum number of tests you want to execute.  Allows you
     to run at most <NUMBER> tests in a program execution.
 --max-test-loop-count <NUMBER>
     When this option is present, test execution will be limited by the number
     of times the test executes its main execution loop. This option augments
     the time-based options in that the test will end if either the test time
     condition is exceeded, or the test-max-loop-count is exhausted.  The use
     of --max-test-loop-count disables test fracturing, the default mode of
     test execution in which individual tests are run multiple times with
     different random number seeds during the same invocation of opendcdiag.
     A value of 0 for --max-test-loop-count is interpreted as there being no
     limit to the number of loop iterations.  This special value can be
     used to disable test fracturing.  When specified tests will not be
     fractured and their execution will be time limited.
 --cpuset=<set>
     Selects the CPUs to run tests on. The <set> option may be a comma-separated
     list of either plain numbers that select based on the system's logical
     processor number, or a letter  followed by a number to select based on
     topology: p for package, c for core and t for thread.
 --dump-cpu-info
     Prints the CPU information that the tool detects (package ID, core ID,
     thread ID, microcode, and PPIN) then exit.
 -e <test>, --enable=<test>, --disable=<test>
     Selectively enable/disable a given test. Can be given multiple times.
     <test> is a test's ID (see the -l option), a wildcard matching test IDs.
     or a test group (starting with @).
 --ignore-os-error, --ignore-timeout
     Continue execution of Sandstone even if a test encounters an operating
     system error (this includes tests timing out).
 --ignore-unknown-tests
     Ignore unknown tests listed on --enable and --disable.
 -h, --help
     Print help.
 -l, --list
     Lists the tests and groups, with their descriptions, and exits.
 --list-tests
     Lists the test names.
 --list-groups
     Lists the test groups.
 --max-messages <NUMBER>
     Limits the maximum number of log messages that can be output by a single
     thread per test invocation.  A value of less than or equal to 0 means
     that there is no limit.  The default value is 5.
 --max-logdata <NUMBER>
     Limits the maximum number of bytes of binary data that can be logged
     by a single thread per test invocation.  A value of less than or equal
     to 0 means that there is no limit.  The default value is 128.
     Sandstone will not log partial data, so if the binary data would cause
     the thread to exceed this threshold it simply will not be output.
 -n <NUMBER>, --threads=<NUMBER>
     Set the number of threads to be run to <NUMBER>. If not specified or if
     0 is passed, then the test defaults to the number of CPUs in the system.
     Note the --cpuset and this parameter do not behave well together.
 -o, --output-log <FILE>
     Place all logging information in <FILE>.  By default, a file name is
     auto-generated by the program.  Use -o /dev/null to suppress creation of any file.
 -s <STATE>, --rng-state=<STATE>
     Specify the random generator state to reload. The seed is in the form:
       Engine:engine-specific-data
 -v, -q, --verbose, --quiet
     Set logging output verbosity level.  Default is quiet.
 --version
     Display program version information.
 --1sec, --30sec, --2min, --5min
     Run for the specified amount of time in the option. In this mode, the program
     prioritizes test execution based on prior detections.
     These options are intended to drive coverage over multiple runs.
     Test priority is ignored when running in combination with the
     --test-list-file option.
 --test-list-file <file path>
     Specifies the tests to run in a text file.  This will run the tests
     in the order they appear in the file and also allows you to vary the
     individual test durations.  See the User Guide for details.
 --test-range A-B
     Run tests from test number A to test number B based on their list location
     in an input file specified using --test-list-file <inputfile>.
     For example: --test-list-file mytests.list -test-range 6-10
                  runs tests 6 through 10 from the file mytests.list.
     See User Guide for more details.
 --test-list-randomize
     Randomizes the order in which tests are executed.
 --test-delay <time in ms>
     Delay between individual test executions in milliseconds.
  -Y, --yaml [<indentation>]
     Use YAML for logging. The optional argument is the number of spaces to
     indent each line by (defaults to 0).

For more options and information, please see the User Reference
Guide.
)";

    static const char restrictedUsageText[] = R"(%s [options]

Available command-line options are:
 -h, --help         Print help.
 -q, --query        Reports whether a scan service found an issue and exits.
 -s, --service      Run as a slow scan service.
     --version      Display version number.
)";

    printf(SandstoneConfig::RestrictedCommandLine ? restrictedUsageText : usageText, argv[0]);
}


#define TO_STRING(x) #x

enum class OutOfRangeMode { Exit, Saturate };
template <typename Integer = int> struct ParseIntArgument
{
    static_assert(std::is_signed_v<Integer> || std::is_unsigned_v<Integer>);
    using MaxInteger = std::conditional_t<std::is_signed_v<Integer>, long long, unsigned long long>;

    const char *name = nullptr;
    const char *explanation = nullptr;
    MaxInteger min = 0;
    MaxInteger max = std::numeric_limits<Integer>::max();
    const int base = 10;
    OutOfRangeMode range_mode = OutOfRangeMode::Exit;

    void print_explanation() const
    {
        // i18n style guide says to never construct sentences...
        if (explanation)
            fprintf(stderr, "%s: value is %s\n", program_invocation_name, explanation);
    }

    void print_range_error(const char *arg) const
    {
        const char *severity = "warning";
        if (range_mode == OutOfRangeMode::Exit)
            severity = "error";
        if constexpr (std::is_signed_v<Integer>) {
            fprintf(stderr,
                    "%s: %s: value out of range for option '%s': %s (minimum is %lld, maximum %lld)\n",
                    program_invocation_name, severity, name, arg, min, max);
        } else {
            fprintf(stderr,
                    "%s: %s: value out of range for option '%s': %s (minimum is %llu, maximum %llu)\n",
                    program_invocation_name, severity, name, arg, min, max);
        }
        print_explanation();
    }

    Integer operator()(int arg) const
    {
        assert(min <= max);
        assert(Integer(min) == min);
        assert(Integer(max) == max);

        // validate range
        if (arg < min || arg > max) {
            print_range_error(TO_STRING(arg));
            if (range_mode == OutOfRangeMode::Exit)
                exit(EX_USAGE);

            if (arg < min)
                arg = Integer(min);
            else if (arg > max)
                arg = Integer(max);
        }
        return arg;
    }

    // non-const because this usually comes from optarg anyway
    Integer operator()(char *arg = optarg) const
    {
        assert(name);
        assert(arg);
        assert(min <= max);
        assert(Integer(min) == min);
        assert(Integer(max) == max);

        char *end = arg;
        errno = 0;
        MaxInteger parsed;
        if constexpr (std::is_signed_v<Integer>)
            parsed = strtoll(arg, &end, base);
        else
            parsed = strtoull(arg, &end, base);

        if (*end != '\0' || *arg == '\0') {
            // strtoll() did not consume the entire string or there wasn't anything to consume,
            // so it can't be valid
            fprintf(stderr, "%s: invalid argument for option '%s': %s\n", program_invocation_name,
                    name, arg);
            print_explanation();
            exit(EX_USAGE);
        }

        // validate range
        Integer v = Integer(parsed);
        bool erange = (errno == ERANGE);
        if (erange || v != parsed || v < min || v > max) {
            print_range_error(arg);
            if (range_mode == OutOfRangeMode::Exit)
                exit(EX_USAGE);

            if (parsed < min || (erange && parsed == std::numeric_limits<long long>::min()))
                v = Integer(min);
            else if (v > max || (erange && parsed == std::numeric_limits<long long>::max()))
                v = Integer(max);
        }
        return v;
    }
};

void validate_excludes_with(const po::variables_map& vm, const char* this_opt, std::vector<const char*> opts) {
    for (auto opt: opts) {
        if (vm.count(opt)) {
            throw std::invalid_argument(boost::str(boost::format("Options %1% and %2% are mutually exclusive") % this_opt % opt));
        }
    }
}

// helper class to handle both '-v -v' and '-vv' in command line
class VerbosityCounter : public po::typed_value<int>
{
public:
    VerbosityCounter():
        VerbosityCounter(nullptr)
    {}

    VerbosityCounter(int* store):
        po::typed_value<int>(store)
    {
        default_value(0);
        zero_tokens();
    }

    virtual ~VerbosityCounter()
    {}

    virtual void xparse(boost::any& store, const std::vector<std::string>& /*tokens*/) const
    {
        if (count < INT_MAX) { // arbitrary
            store = boost::any(++count);
        }
    }

private:
    mutable int count = 0;
};

int parse_testrun_range(const char *arg, int &starting_test_number, int &ending_test_number) {
    char *end;
    errno = 0;
    starting_test_number = strtoul(arg, &end, 10);
    if (errno == 0) {
        if (*end == '-')
            ending_test_number = strtoul(end + 1, &end, 10);
        else
            errno = EINVAL;
    }
    if (errno != 0) {
        fprintf(stderr, "%s: error: --test-range requires two dash separated integer args like --test-range 1-10\n",
                program_invocation_name);
        return EXIT_FAILURE;
    }
    if (starting_test_number > ending_test_number)
        std::swap(starting_test_number, ending_test_number);
    if (starting_test_number < 1) {
        fprintf(stderr, "%s: error: The lower bound of the test range must be >= 1, %d specified\n",
                program_invocation_name, starting_test_number);
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

void dump_cpu_info(int verbosity) {
    int i;

    // find the best matching CPU
    const char *detected = "<unknown>";
    for (const auto &arch : x86_architectures) {
        if ((arch.features & cpu_features) == arch.features) {
            detected = arch.name;
            break;
        }
        if (verbosity > 1) {
            printf("CPU is not %s: missing %s\n", arch.name,
                   cpu_features_to_string(arch.features & ~cpu_features).c_str());
        }
    }
    printf("Detected CPU: %s; family-model-stepping (hex): %02x-%02x-%02x; CPU features: %s\n",
           detected, cpu_info[0].family, cpu_info[0].model, cpu_info[0].stepping,
           cpu_features_to_string(cpu_features).c_str());
    printf("# CPU\tPkgID\tCoreID\tThrdID\tMicrocode\tPPIN\n");
    for (i = 0; i < num_cpus(); ++i) {
        printf("%d\t%d\t%d\t%d\t0x%" PRIx64, cpu_info[i].cpu_number,
               cpu_info[i].package_id, cpu_info[i].core_id, cpu_info[i].thread_id,
               cpu_info[i].microcode);
        if (cpu_info[i].ppin) {
            printf("\t%016" PRIx64, cpu_info[i].ppin);
        }
        puts("");
    }
}

auto collate_test_groups(SandstoneTestSet& test_set) {
    struct Group {
        const struct test_group *definition = nullptr;
        std::vector<const struct test *> entries;
    };
    std::map<std::string_view, Group> groups;
    for (const auto &ti : test_set) {
        for (auto ptr = ti.test->groups; ptr && *ptr; ++ptr) {
            Group &g = groups[(*ptr)->id];
            g.definition = *ptr;
            g.entries.push_back(ti.test);
        }
    }

    return groups;
}

void list_tests(SandstoneTestSet& test_set, bool include_tests, bool include_groups, bool include_descriptions, const SandstoneApplication* app)
{
    auto groups = collate_test_groups(test_set);
    int i = 0;

    for (const auto &ti : test_set) {
        struct test *test = ti.test;
        if (test->quality_level >= app->requested_quality) {
            if (include_tests) {
                if (include_descriptions) {
                    printf("%i %-20s \"%s\"\n", ++i, test->id, test->description);
                } else if (app->shmem->verbosity > 0) {
                    // don't report the FW minimum CPU features
                    uint64_t cpuf = test->compiler_minimum_cpu & ~_compilerCpuFeatures;
                    cpuf |= test->minimum_cpu;
                    printf("%-20s %s\n", test->id, cpu_features_to_string(cpuf).c_str());
                } else {
                    puts(test->id);
                }
            }
        }
    }

    if (include_groups && !groups.empty()) {
        if (include_descriptions)
            printf("\nGroups:\n");
        for (auto pair : groups) {
            const auto &g = pair.second;
            if (include_descriptions) {
                printf("@%-21s \"%s\"\n", g.definition->id, g.definition->description);
                for (auto test : g.entries)
                    if (test->quality_level >= app->requested_quality)
                        printf("  %s\n", test->id);
            } else {
                // just the group name
                printf("@%s\n", g.definition->id);
            }
        }
    }
}

void list_group_members(SandstoneTestSet& test_set, const char *groupname)
{
    auto groups = collate_test_groups(test_set);
    for (auto pair : groups) {
        const auto &g = pair.second;
        if (groupname[0] == '@' && strcmp(g.definition->id, groupname + 1) == 0) {
            for (auto test : g.entries)
                printf("%s\n", test->id);
            return;
        }
    }

    fprintf(stderr, "No such group '%s'\n", groupname);
    exit(EX_USAGE);
}
}

std::optional<ParsedOpts> parse_and_validate(int argc, char **argv, SandstoneApplication* app) {
    ParsedOpts res{};
    po::options_description options("Options");
    options.add_options()
        ("help,h", po::value<bool>()->implicit_value(true)->zero_tokens(), "Print help.") // use value<bool> rather than bool_switch to further use vm.count() (for bool_switch vm.count() is always true)
        ("enable,e", po::value<std::vector<std::string>>(&res.enabled_tests)->multitoken()->composing(),
            "Selectively enable a given test. Can be given multiple times. " \
            "<test> is a test's ID (see the -l option), a wildcard matching test IDs. " \
            "or a test group (starting with @).")
        ("disable", po::value<std::vector<std::string>>(&res.disabled_tests)->multitoken()->composing(),
            "Selectively disable a given test. Can be given multiple times. " \
            "<test> is a test's ID (see the -l option), a wildcard matching test IDs. " \
            "or a test group (starting with @).")
        ("test-list-randomize", po::bool_switch(&res.test_set_config.randomize), "Randomizes the order in which tests are executed.")
        ("max-messages", po::value<int>(),
            "Limits the maximum number of log messages that can be output by a single " \
            "thread per test invocation.  A value of less than or equal to 0 means " \
            "that there is no limit.  The default value is 5.")
        ("no-slicing", po::value<bool>()->implicit_value(true)->zero_tokens(), "No slicing")
        ("beta", po::value<bool>()->implicit_value(true)->zero_tokens(), "Beta tests")
        ("quality", po::value<int>(), "Quality")
        ("rng-state,s", po::value<std::string>(&res.seed),
            "Specify the random generator state to reload. The seed is in the form:\n" \
            "Engine:engine-specific-data")
        ("quiet,q", po::value<bool>()->implicit_value(true)->zero_tokens(), "Set logging output verbosity level.  Default is quiet.")
        ("fatal-errors,F", po::bool_switch(&res.fatal_errors), "Stop execution after first failure; do not continue to run tests.")
        ("fatal-skips", po::bool_switch(&app->fatal_skips), "Fatal skips")
        ("ignore-unknown-tests", po::bool_switch(&res.test_set_config.ignore_unknown_tests), "Ignore unknown tests")
        ("output-log,o", po::value<std::string>(&app->file_log_path),
            "Place all logging information in <FILE>.  By default, a file name is " \
            "auto-generated by the program.  Use -o /dev/null to suppress creation of any file.")
        ("test-option,O", po::value<std::string>()->multitoken(), "Test option")
        ("time,t", po::value<std::string>(),
            "Specify the execution time per test for the program in ms. " \
            "Value for this field can also be specified with a label s, m, h for seconds, " \
            "minutes or hours.  Example: 200ms, 2s or 2m")
        ("total-time,T", po::value<std::string>(),
            "Specify the minimum run time for the program.  A special value for <time> " \
            "of \"forever\" causes the program to loop indefinitely.  The defaults for <time> " \
            "is milliseconds, with s, m, and h available for seconds, minutes or hours. " \
            "Example: sandstone -T 60s     # run for at least 60 seconds. " \
            "Example: sandstone -T 5000    # run for at least 5,000 milliseconds")
        ("verbose,v", new VerbosityCounter(&app->shmem->verbosity), "Set logging output verbosity level.  Default is quiet.")
        ("force-test-time", po::bool_switch(&app->force_test_time), "Force test time")
        ("timeout", po::value<std::vector<std::string>>(), "Timeout") // TODO right now selftests require support for options overwriting
        ("dump-cpu-info", po::value<bool>()->implicit_value(true)->zero_tokens(),
            "Prints the CPU information that the tool detects (package ID, core ID, " \
            "thread ID, microcode, and PPIN) then exit.")
        ("on-hang", po::value<std::vector<std::string>>(), "On hang") // TODO right now selftests require support for options overwriting
        ("on-crash", po::value<std::vector<std::string>>(), "On crash") // TODO right now selftests require support for options overwriting
        ("ignore-os-errors", po::value<bool>()->implicit_value(true)->zero_tokens(),
            "Continue execution of Sandstone even if a test encounters an operating " \
            "system error")
        ("ignore-timeout", po::value<bool>()->implicit_value(true)->zero_tokens(),
            "Continue execution of Sandstone even if a test times out.")
        ("threads,n", po::value<std::vector<int>>(),
            "Set the number of threads to be run to <NUMBER>. If not specified or if " \
            "0 is passed, then the test defaults to the number of CPUs in the system. " \
            "Note the --cpuset and this parameter do not behave well together.")
        ("list,l", po::value<bool>()->implicit_value(true)->zero_tokens(), "Lists the tests and groups, with their descriptions, and exits.")
        ("list-tests", po::value<bool>()->implicit_value(true)->zero_tokens(), "Lists the test names.")
        ("list-groups", po::value<bool>()->implicit_value(true)->zero_tokens(), "Lists the test groups.")
        ("list-group-members", po::value<std::string>(), "List group members")
        ("yaml,Y", po::value<std::vector<int>>()->multitoken()->composing()->zero_tokens(),
            "Use YAML for logging. The optional argument is the number of spaces to " \
            "indent each line by (defaults to 0).")
        ("cpuset", po::value<std::string>(),
            "Selects the CPUs to run tests on. The <set> option may be a comma-separated " \
            "list of either plain numbers that select based on the system's logical " \
            "processor number, or a letter  followed by a number to select based on " \
            "topology: p for package, c for core and t for thread.")
        ("max-cores-per-slice", po::value<int>(), "Max cores per slice")
        ("mce-check-every", po::value<int>(&app->mce_check_period), "Mce check period")
        ("output-format", po::value<std::string>(), "Output format")
        ("quick", po::value<bool>()->implicit_value(true)->zero_tokens(), "Quick run")
        ("strict-runtime", po::bool_switch(&app->shmem->use_strict_runtime),
            "Use in conjunction with -T to force the program to stop execution after the specific time has elapsed.")
        ("retest-on-failure", po::value<std::vector<int>>(), "Retest on failure") // TODO right now selftests require support for options overwriting
        ("syslog", po::value<bool>()->implicit_value(true)->zero_tokens(), "Syslog")
        ("service", po::value<bool>()->implicit_value(true)->zero_tokens(), "Service")
        ("ud-on-failure", po::bool_switch(&app->shmem->ud_on_failure), "UD on failure")
        ("use-builtin-test-list", po::value<std::string>()->implicit_value(std::string{}), "Use built-in test list")
        ("temperature-threshold", po::value<std::string>(), "Temperature threshold")
        ("test-delay", po::value<std::string>(), "Delay between individual test executions in milliseconds.")
        ("test-tests", po::value<bool>()->implicit_value(true)->zero_tokens(), "Test tests")
        ("total-retest-on-failure", po::value<int>(), "Total retest on failure")
        ("test-list-file", po::value<std::string>(&res.test_list_file_path),
            "Specifies the tests to run in a text file.  This will run the tests " \
            "in the order they appear in the file and also allows you to vary the " \
            "individual test durations.  See the User Guide for details.")
        ("fork-mode,f", po::value<std::string>(), "Fork mode")
        ("test-range", po::value<std::string>(),
            "Run tests from test number A to test number B based on their list location " \
            "in an input file specified using --test-list-file <inputfile>. " \
            "For example: --test-list-file mytests.list -test-range 6-10 " \
            "      runs tests 6 through 10 from the file mytests.list. " \
            "See User Guide for more details.")
        ("max-logdata", po::value<int>(),
            "Limits the maximum number of bytes of binary data that can be logged " \
            "by a single thread per test invocation.  A value of less than or equal " \
            "to 0 means that there is no limit.  The default value is 128. " \
            "Sandstone will not log partial data, so if the binary data would cause " \
            "the thread to exceed this threshold it simply will not be output.")
        ("vary-frequency", po::value<bool>()->implicit_value(true)->zero_tokens(), "Vary frequency")
        ("vary-uncore-frequency", po::value<bool>()->implicit_value(true)->zero_tokens(), "Vary uncore frequency")
        ("version", po::value<bool>()->implicit_value(true)->zero_tokens(), "Display program version information.")
        ("1sec", po::value<bool>()->implicit_value(true)->zero_tokens(), "1 sec")
        ("30sec", po::value<bool>()->implicit_value(true)->zero_tokens(), "30 sec")
        ("2min", po::value<bool>()->implicit_value(true)->zero_tokens(), "2 min")
        ("5min", po::value<bool>()->implicit_value(true)->zero_tokens(), "5 min")
        ("max-test-count", po::value<int>(&app->max_test_count),
            "Specify the maximum number of tests you want to execute.  Allows you " \
            "to run at most <NUMBER> tests in a program execution.")
        ("max-test-loop-count", po::value<int>(),
            "When this option is present, test execution will be limited by the number " \
            "of times the test executes its main execution loop. This option augments " \
            "the time-based options in that the test will end if either the test time " \
            "condition is exceeded, or the test-max-loop-count is exhausted.  The use " \
            "of --max-test-loop-count disables test fracturing, the default mode of " \
            "test execution in which individual tests are run multiple times with " \
            "different random number seeds during the same invocation of opendcdiag. " \
            "A value of 0 for --max-test-loop-count is interpreted as there being no " \
            "limit to the number of loop iterations.  This special value can be " \
            "used to disable test fracturing.  When specified tests will not be " \
            "fractured and their execution will be time limited.")
#ifndef NDEBUG
        ("gdb-server", po::value<std::string>(&app->gdb_server_comm), "GDB Server")
        ("is-debug-build", po::value<bool>()->zero_tokens(), "Is debug build")
#endif
#if defined(__SANITIZE_ADDRESS__)
        ("is-asan-build", po::value<bool>()->zero_tokens(), "Is ASAN build")
#endif
#ifndef NO_SELF_TESTS
        ("selftests", po::value<bool>()->implicit_value(true)->zero_tokens(), "Self tests")
#endif
    ;

    po::options_description deprecated("Deprecated");
    deprecated.add_options()
        ("longer-runtime", po::value<uint8_t>()->implicit_value(0)) // accept with or without argument as well
        ("max-concurrent-threads", po::value<uint8_t>()->implicit_value(0))
        ("no-triage", po::value<uint8_t>()->implicit_value(0))
        ("triage", po::value<uint8_t>()->implicit_value(0))
        ("schedule-by", po::value<uint8_t>()->implicit_value(0))
        ("shorten-runtime", po::value<uint8_t>()->implicit_value(0))
        ("weighted-testrun-type", po::value<uint8_t>()->implicit_value(0))
        ("mem-sample-time", po::value<uint8_t>()->implicit_value(0))
        ("mem-samples-per-log", po::value<uint8_t>()->implicit_value(0))
        ("no-memory-sampling", po::value<uint8_t>()->implicit_value(0))
    ;

    po::options_description desc("All Options");
    desc.add(options).add(deprecated);

    po::options_description desc_no_cmd("Options");
    desc_no_cmd.add_options()
        ("help,h", po::value<bool>()->implicit_value(true)->zero_tokens(), "Print help.")
        ("query", po::value<bool>()->implicit_value(true)->zero_tokens(), "Reports whether a scan service found an issue and exits.")
        ("service", po::value<bool>()->implicit_value(true)->zero_tokens(), "Run as a slow scan service.")
        ("version", po::value<bool>()->implicit_value(true)->zero_tokens(), "Display version number.")
    ;

    if (!SandstoneConfig::RestrictedCommandLine) {
        // parse
        po::variables_map vm;
        po::store(po::parse_command_line(argc, argv, desc), vm);
        po::notify(vm);

        // quality opts need to be parsed before list-tests endpoint
        if (vm.count("beta")) {
            validate_excludes_with(vm, "beta", {"quality"});
            app->requested_quality = 0;
        }
        if (vm.count("quality")) {
            validate_excludes_with(vm, "quality", {"beta"});
            app->requested_quality = ParseIntArgument<>{
                    .name = "--quality",
                    .min = -1000,
                    .max = +1000,
                    .range_mode = OutOfRangeMode::Saturate
            }(vm["quality"].as<int>());
        }
        // cpuset before dump-cpu-info
        if (vm.count("cpuset")) {
            auto value = vm["cpuset"].as<std::string>();
            apply_cpuset_param(app, &value[0]);
        }

#ifndef NO_SELF_TESTS
        if (vm.count("selftests")) {
            if (vm.count("beta") || vm.count("quality")) {
                throw std::invalid_argument(boost::str(boost::format("%1%: --selftest is incompatible with --beta or --quality.") % argv[0]));
            }
            app->requested_quality = 0;
            app->shmem->selftest = true;
            res.test_set_config.is_selftest = true;
        }
#endif

        // endpoints
        if (vm.count("help")) {
            validate_excludes_with(vm, "help", {"dump-cpu-info", "list", "list-tests", "list-groups", "list-group-members", "version"});
            usage(argv);
            // desc.print(std::cout); // TODO: which one do we prefer? usage() has less options described, desc will always show all of them
            return {};
        }
        if (vm.count("dump-cpu-info")) {
            validate_excludes_with(vm, "dump-cpu-info", {"help", "list", "list-tests", "list-groups", "list-group-members", "version"});
            dump_cpu_info(app->shmem->verbosity); // app->shmem->verbosity is already parsed
            return {};
        }
        if (vm.count("list") || vm.count("list-tests") || vm.count("list-groups")) {
            validate_excludes_with(vm, "list", {"help", "dump-cpu-info", "list-group-members", "version"});
            SandstoneTestSet test_set{res.test_set_config, SandstoneTestSet::enable_all_tests};
            list_tests(test_set, !vm.count("list-groups"), !vm.count("list-tests"), vm.count("list"), app);
            return {};
        }
        if (vm.count("list-group-members")) {
            validate_excludes_with(vm, "list-group-members", {"help", "dump-cpu-info", "list", "list-tests", "list-groups", "version"});
            SandstoneTestSet test_set{res.test_set_config, SandstoneTestSet::enable_all_tests};
            auto value = vm["list-group-members"].as<std::string>();
            list_group_members(test_set, value.c_str());
            return {};
        }
        if (vm.count("version")) {
            validate_excludes_with(vm, "version", {"help", "dump-cpu-info", "list", "list-tests", "list-groups", "list-group-members"});
            logging_print_version();
            return {};
        }
        if (vm.count("is-debug-build") || vm.count("is-asan-build")) {
            // these options are only accessible in the command-line if the
            // corresponding functionality is active
            return {};
        }

        if (vm.count("ignore-timeout") || vm.count("ignore-os-errors")) {
            app->ignore_os_errors = true;
        }
        if (vm.count("on-crash")) {
            auto value = vm["on-crash"].as<std::vector<std::string>>();
            if (value.size() > 1) {
                fprintf(stderr, "Warning: multiple occurences of --on-crash, picking the last one\n");
            }
            res.on_crash_arg = value.back();
        }
        if (vm.count("on-hang")) {
            auto value = vm["on-hang"].as<std::vector<std::string>>();
            if (value.size() > 1) {
                fprintf(stderr, "Warning: multiple occurences of --on-hang, picking the last one\n");
            }
            res.on_hang_arg = value.back();
        }
        if (vm.count("no-slicing")) {
            validate_excludes_with(vm, "no-slicing", {"max-cores-per-slice"});
            res.max_cores_per_slice = -1;
        }
        if (vm.count("max-messages")) {
            app->shmem->max_messages_per_thread = ParseIntArgument<>{
                    .name = "max-messages",
                    .min = -1,
                    .range_mode = OutOfRangeMode::Saturate
            }(vm["max-messages"].as<int>());
            if (app->shmem->max_messages_per_thread <= 0) { // TODO introduce new OutOfRangeMode::SaturateWithMax to handle this case?
                app->shmem->max_messages_per_thread = INT_MAX;
            }
        }
        if (vm.count("quiet")) {
            // validate_excludes_with(vm, "quiet", {"verbose"}); // TODO verbose has custom parser which makes vm.count("verbose") always true
            app->shmem->verbosity = 0;
        }
        if (vm.count("test-option")) {
            app->shmem->log_test_knobs = true;
            auto values = vm["test-option"].as<std::vector<std::string>>();
            for (const auto& value: values) {
                if (!set_knob_from_key_value_string(value.c_str())){
                    throw std::invalid_argument(boost::str(boost::format("Malformed test knob: %1% (should be in the form KNOB=VALUE)") % value));
                }
            }
        }
        if (vm.count("time")) {
            app->test_time = string_to_millisecs(vm["time"].as<std::string>());
        }
        if (vm.count("total-time")) {
            validate_excludes_with(vm, "total-time", {"service"});
            auto value = vm["total-time"].as<std::string>();
            if (value == "forever") {
                app->endtime = MonotonicTimePoint::max();
            } else {
                app->endtime = app->starttime + string_to_millisecs(value);
            }
            res.test_set_config.cycle_through = true; /* Time controls when the execution stops as
                                                        opposed to the number of tests. */
        }
        if (vm.count("timeout")) {
            auto value = vm["timeout"].as<std::vector<std::string>>();
            if (value.size() > 1) {
                fprintf(stderr, "Warning: multiple occurences of --timeout, picking the last one\n");
            }
            app->max_test_time = string_to_millisecs(value.back());
        }
        if (vm.count("threads")) {
            auto value = vm["threads"].as<std::vector<int>>();
            if (value.size() > 1) {
                fprintf(stderr, "Warning: multiple occurences of --threads, picking the last one\n");
            }
            res.thread_count = ParseIntArgument<>{
                .name = "-n / --threads",
                .min = 1,
                .max = app->thread_count,
                .range_mode = OutOfRangeMode::Saturate,
            }(value.back());
        }
        if (vm.count("yaml")) {
            // accept "-y -y4" - useful in selftests
            // -y   activate yaml output format
            // -y4  activate yaml output format + set indentation
            app->shmem->output_format = SandstoneApplication::OutputFormat::yaml;
            auto value = vm["yaml"].as<std::vector<int>>();
            if (value.size() > 1) { // vector contains only args with values
                fprintf(stderr, "Warning: multiple occurences of --yaml, picking the last one\n");
            }
            if (value.size() >= 1) {
                app->shmem->output_yaml_indent = ParseIntArgument<>{
                    .name = "-y / --yaml",
                    .max = 160,     // arbitrary
                }(value.back());
            }
        }
        if (vm.count("max-cores-per-slice")) {
            validate_excludes_with(vm, "max-cores-per-slice", {"no-slicing"});
            res.max_cores_per_slice = ParseIntArgument<>{
                .name = "--max-cores-per-slice",
                .min = -1,
            }(vm["max-cores-per-slice"].as<int>());
        }
        if (vm.count("output-format")) {
            auto value = vm["output-format"].as<std::string>();
            if (value != "yaml") {
                validate_excludes_with(vm, "output-format", {"yaml"});
            }
            if (value == "key-value") {
                app->shmem->output_format = SandstoneApplication::OutputFormat::key_value;
            } else if (value == "tap") {
                app->shmem->output_format = SandstoneApplication::OutputFormat::tap;
            } else if (value == "yaml") {
                app->shmem->output_format = SandstoneApplication::OutputFormat::yaml;
            } else if (SandstoneConfig::Debug && value == "none") {
                // for testing only
                validate_excludes_with(vm, "output-format", {"verbosity", "quiet"});
                app->shmem->output_format = SandstoneApplication::OutputFormat::no_output;
                app->shmem->verbosity = -1;
            } else {
                throw std::invalid_argument(boost::str(boost::format("%1%: unknown output format: %2%") % argv[0] % value));
            }
        }
        if (vm.count("quick")) {
            app->max_test_loop_count = 1;
            app->delay_between_tests = 0ms;
        }
        if (vm.count("retest-on-failure")) {
            auto value = vm["retest-on-failure"].as<std::vector<int>>();
            if (value.size() > 1) {
                fprintf(stderr, "Warning: multiple occurences of --retest-on-failure, picking the last one\n");
            }
            app->retest_count = ParseIntArgument<>{
                    .name = "--retest-on-failure",
                    .max = SandstoneApplication::MaxRetestCount,
                    .range_mode = OutOfRangeMode::Saturate
            }(value.back());
        }
        if (vm.count("syslog")) {
            app->syslog_ident = program_invocation_name;
        }
        if (vm.count("service")) {
            // keep in sync with RestrictedCommandLine below
            validate_excludes_with(vm, "service", {"total-time"});
            res.fatal_errors = true;
            app->endtime = MonotonicTimePoint::max();
            app->service_background_scan = true;
        }
        if (vm.count("use-builtin-test-list")) {
            auto value = vm["use-builtin-test-list"].as<std::string>();
            if (!SandstoneConfig::HasBuiltinTestList) {
                throw std::invalid_argument(boost::str(boost::format("%1%: --use-builtin-test-list specified but this build does not "
                                "have a built-in test list.") % argv[0]));
            }
            res.builtin_test_list_name = !value.empty() ? value : "auto";
        }
        if (vm.count("temperature-threshold")) {
            if (vm["temperature-threshold"].as<std::string>() == "disable") {
                app->thermal_throttle_temp = -1;
            } else {
                auto value = vm["temperature-threshold"].as<std::string>();
                app->thermal_throttle_temp = ParseIntArgument<>{
                    .name = "--temperature-threshold",
                    .explanation = "value should be specified in thousands of degrees Celsius "
                                    "(for example, 85000 is 85 degrees Celsius), or \"disable\" "
                                    "to disable monitoring",
                    .max = 160000,      // 160 C is WAAAY too high anyway
                    .range_mode = OutOfRangeMode::Saturate
                }(&value[0]);
            }
        }
        if (vm.count("test-delay")) {
            auto value = vm["test-delay"].as<std::string>();
            app->delay_between_tests = string_to_millisecs(value);
        }
        if (vm.count("test-tests")) {
            app->enable_test_tests();
            if (app->test_tests_enabled()) {
                // disable other options that don't make sense in this mode
                app->retest_count = 0;
            }
        }
        if (vm.count("total-retest-on-failure")) {
            app->total_retest_count = ParseIntArgument<>{
                    .name = "--total-retest-on-failure",
                    .min = -1
            }(vm["total-retest-on-failure"].as<int>());
        }
        if (vm.count("fork-mode")) {
            auto value = vm["fork-mode"].as<std::string>();
            if (value == "no" || value == "no-fork") {
                app->fork_mode = SandstoneApplication::no_fork;
            } else if (value == "exec") {
                app->fork_mode = SandstoneApplication::exec_each_test;
#ifndef _WIN32
            } else if (value == "yes" || value == "each-test") {
                app->fork_mode = SandstoneApplication::fork_each_test;
#endif
            } else {
                throw std::invalid_argument(boost::str(boost::format("%1%: unknown option to -f: %1%") % argv[0] % value));
            }
        }
        if (vm.count("test-range")) {
            auto value = vm["test-range"].as<std::string>();
            if (parse_testrun_range(value.c_str(), res.starting_test_number, res.ending_test_number) == EXIT_FAILURE) {
                throw std::invalid_argument("wrong test range");
            }
        }
        if (vm.count("max-logdata")) {
            app->shmem->max_logdata_per_thread = ParseIntArgument<unsigned>{
                    .name = "--max-logdata",
                    .explanation = "maximum number of bytes of test's data to log per thread (0 is unlimited))",
                    .base = 0,      // accept hex
                    .range_mode = OutOfRangeMode::Saturate
            }(vm["max-logdata"].as<int>());
            if (app->shmem->max_logdata_per_thread == 0) { // here OutOfRangeMode::SaturateWithMax as well?
                app->shmem->max_logdata_per_thread = UINT_MAX;
            }
        }
        if (vm.count("vary-frequency")) {
            if (!FrequencyManager::FrequencyManagerWorks) {
                throw std::invalid_argument(boost::str(boost::format("%1%: --vary-frequency works only on Linux") % program_invocation_name));
            }
            app->vary_frequency_mode = true;
        }
        if (vm.count("vary-uncore-frequency")) {
            if (!FrequencyManager::FrequencyManagerWorks) {
                throw std::invalid_argument(boost::str(boost::format("%1%: --vary-uncore-frequency works only on Linux") % program_invocation_name));
            }
            app->vary_uncore_frequency_mode = true;
        }
        if (vm.count("1sec") || vm.count("30sec") || vm.count("2min") || vm.count("5min")) { // they should be mutually exclusive
            res.test_set_config.randomize = true;
            res.test_set_config.cycle_through = true;
            app->shmem->use_strict_runtime = true;
            if (vm.count("1sec")) {
                validate_excludes_with(vm, "1sec", {"30sec", "2min", "5min"});
                app->endtime = app->starttime + 1s;
            }
            else if (vm.count("30sec")) {
                validate_excludes_with(vm, "30sec", {"1sec", "2min", "5min"});
                app->endtime = app->starttime + 30s;
            }
            else if (vm.count("2min")) {
                validate_excludes_with(vm, "2min", {"1sec", "30sec", "5min"});
                app->endtime = app->starttime + 2min;
            }
            else if (vm.count("5min")) {
                validate_excludes_with(vm, "5min", {"1sec", "30sec", "2min"});
                app->endtime = app->starttime + 5min;
            }
        }
        if (vm.count("max-test-loop-count")) {
            app->max_test_loop_count = ParseIntArgument<>{"--max-test-loop-count"}(vm["max-test-loop-count"].as<int>());
            if (app->max_test_loop_count == 0) {
                app->max_test_loop_count = std::numeric_limits<int>::max(); // TODO: saturate with max on both sides
            }
        }
        // deprecated
        if (vm.count("longer-runtime") || vm.count("max-concurrent-threads") || vm.count("no-triage") ||
            vm.count("triage") || vm.count("schedule-by") || vm.count("shorten-runtime") || vm.count("weighted-testrun-type") ||
            vm.count("mem-sample-time") || vm.count("mem-samples-per-log") || vm.count("no-memory-sampling"))
        {
            fprintf(stderr, "%s: option is ignored and will be removed in a future version.\n",
                program_invocation_name);
        }
    }

     if (SandstoneConfig::RestrictedCommandLine) {
        // Default options for the simplified OpenDCDiag cmdline

        // parse
        po::variables_map vm;
        po::store(po::parse_command_line(argc, argv, desc_no_cmd), vm);
        po::notify(vm);

        // validate
        if (vm.count("help")) {
            usage(argv);
            // desc_no_cmd.print(std::cout);
            return {};
        }
        if (vm.count("query")) {
            // ### FIXME
            fprintf(stderr, "%s: --query not implemented yet\n", argv[0]);
            abort();
        }
        if (vm.count("service")) {
            // keep in sync above
            app->endtime = MonotonicTimePoint::max();
            app->service_background_scan = true;
        }
        if (vm.count("version")) {
            logging_print_version();
            return {};
        }

        if (SandstoneConfig::NoLogging) {
            app->shmem->output_format = SandstoneApplication::OutputFormat::no_output;
        } else  {
            app->shmem->verbosity = 1;
        }
    }

    return res;
}

